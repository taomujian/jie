# Xor_game

## 解题思路

> 下载附件,得到一个txt文件和一个python文件,里面的加密逻辑非常简单,就是单纯的异或,但是只有密文,没有明文,计算不出来flag...

> key = (key * (len(data) / len(key) + 1))[:len(data)] 将key扩展为可加密data的长度,并将长于(多余)data的部分丢弃.([:len(data)]).扩展方式为重复key,类似维吉尼亚密码.如：明文长度为11,密钥为ok,则密钥扩展为：okokokokoko,只不过这里是异或加密而不是双表替换密码

> 可以通过猜测在明文中的字符来与密文异或,这样就可以得到key,也就是flag,为了提高猜测的准确性,这里使用分组爆破,另外由于flag的长度未知,借用攻击维吉尼亚密码的获悉密钥长度的方法(kasiski test),先假设flag的长度为10,那么在密文中以10个字符为一组进行划分

> 将明文空间中的字符分别与第一组的第i位字符(实际上异或出来的结果也就是flag的第i位结果),第二组的第i位字符进行异或,如果两者异或的结果相同,那么很有可能这个结果就是flag的第i位

```
def getkey(i,j):
    ls = []
    for a in table:
        for b in table:
            if ord(a) ^ enc[i] == ord(b) ^ enc[j]:
                ls.append(chr(ord(a) ^ enc[i]))
    return ls
```

> 不知道key的位数,可以采用爆破的方法,看爆出的key哪个像是flag,因为flag是可见字符并且可以辨认.因为有足够多的组,所以有很小几率取交集剩下有多个字符,但是这里涉及到一个很棘手的问题,就是爆破明文的时候,爆破的字典选取,如果这个字典选择所有可见字符,那么确实每一位最后都会爆出很多个结果.这道题说明文是一首诗,所以能想到的字符集是大小写字母+数字+空格、换行+标点符号.


## flag

> hctf{xor_is_interesting!@#}

## 参考

> https://igml.top/2018/11/13/2018-HCTF/