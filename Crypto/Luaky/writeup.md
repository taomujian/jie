# Luaky

## 解题思路

> 下载附件,得到一个elf文件,linux二进制文件.

> 在这次的挑战中你必须创造一个用LUA脚本语言写的石头剪刀布AI使它能击败服务器.每一轮有100000次石头剪刀布,而你需要赢下其中的90000次才算赢了一轮.服务器一共有三种不同的形态,每一个形态用一种不同的简单的伪随机生成器(state),它的种子来自于/dev/urandom.这三种形态分别是：
Slime：state = (state + 1)%3；cpuhand = state Alpaca：state = ((state +
Slime：state =（state + 1）%3; cpuhand = state Alpaca：state =（（state +
yourlasthand + 0x9E3779B9) % 0x100000000)；cpuhand = state % 3 Nozomi：state =
yourlasthand + 0x9E3779B9）% 0x10000000）; cpuhand = state % 3 Nozomi：状态=
((state * 48271) % 0x7fffffff)；cpuhand = state % 3
（（state * 48271）% 0x7fffffff）; cpuhand =状态% 3

> 你会先和Slime打一轮,再和Alpaca和Nozomi各打上10轮,或直到你输了游戏就会终止.得到第一题的flag你需要赢Alpaca和Nozomi中任意一个10轮.获得第二题的flag你需要赢下一个随机对手（这三种形态中）100轮,当然每轮可能会换形态.

> 你的Lua脚本只需要一个函数,play().它的输入是电脑的上一次出手,输出是你的出手选择（0,1,2）.这次的Lua程序没有明显的安全性漏洞,但你可以使用print语句帮助你调试.另外每一轮都有一秒的时间限制（有些人赛后告诉我在初始脚本装载前没有时间限制,所以你可以利用那段时间进行你得计算）.

> 打败Slime是最简单的——只要返回电脑的上一次出手,那样你就能赢得每一次.

> 打败Alpaca有一点困难.不考虑yourlasthand这个变量因为你可以控制它的取值,我们观察到0x9E3779B9 % 3 == 0.这就意味着如果state < (0x100000000 - 0x9E3779B9),那么电脑的下一招就和会上一次出手一模一样.另一方面,如果state= (0x100000000 - 0x9E3779B9),那电脑就会改变它的下一次出手,而且由于0x100000000 % 3 ==1,这意味着下一次电脑的出手与上一次会完全不一样.所以通过观察前两次电脑的state值你可以缩小state的范围.我们用两个变量,alp_low和alp_high来给state值划一个预计的范围.在几轮之后,这个范围会变得越来越精确这样你就可以预测电脑的每次出招从而轻松地打败它.

> 打败Nozomi是最困难的.我们花了很长的时间尝试运用数学办法来破解电脑的招数,但没有找到任何好办法.过了一会我们开始把重点放在预处理上：我们从state=1开始生成一个包含了电脑的后五招的一个串,然后把它与下一个state一起放在一个查看表里.我们生成了250000个类似的串,把9000种state分隔开.这很容易做到因为Nozomi的生成器是一个循环群.在Python中,我们可以使用pow(48271, 9000, 0x7fffffff) = 1467418072然而在Lua中我们要这么写state * 1467418072 % 0x7fffffff来跳过9000种state.

> 但是,生成这些串需要一段很长的时间.我们决定将生成的过程分散到我们与另两个对手对战的轮中.当表格完成后,我们就可以击败Nozomi.我们取最后50步电脑的出招然后看它是不是属于表格中,如果是的,我们立刻就能从查看表中知道下一个state是什么.由于我们建表的方法,我们确保能在9050种先手中找到一个条目,这样就能让我们赢下许多次在同一轮中.

> 我们获取了第一个flag,它是hitcon{Hey Lu4ky AI, I am Alpaca… MEH!}.

## flag

> hitcon{Hey Lu4ky AI, I am Alpaca… MEH!}