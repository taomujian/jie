# NTRU sample

## 解题思路

> 下载附件,得到一个多个文件文件,看不懂看不懂

> 论文是今年的Single-Trace Side-Channel Attacks on ω-Small Polynomial Sampling: With Applications to NTRU, NTRU Prime, and CRYSTALS-DILITHIUM,主要是分析在算法高斯采样预处理的过程中对三元多项式的直接攻击,除此之外在2018年的另一篇论文中也探讨了在揭秘环节直接攻击三元多项式的一些方案,但因为时间较为久远,对应的代码仓库没有了,猜测是那种实现最终被NTRU官方ban了,所以最后改换了这篇.

> 使用的仿真工具是GitHub - sca-research/GILES,相比于ELMO似乎更好上手些（他本身原来就叫ELMO2）,但是没有合适的出题样例了,所以借这次写个完整的工具使用文档.

> GILES处理的是可以直接移植到arm cortex M0机器上的指令,但同时因为他有仿真所用的部分函数,也不能直接交叉编译,所以我们还需要一个GitHub - sca-research/thumb-sim: Thumb Timing Simulator来生成编译文件.仿真器的函数头使用的是elmo-funcs.h download,主要包括触发器相关的功能和读写字节相关的功能,需要注意的是字节读写似乎需要对齐到某个值,不然无法读取.

> 在利用GILES生成数据的时候,有电源模式和汉明重两种预设模式,但实际体验下来电源模式的数据生成感觉比较草率,不如ELMO的数据看起来真实,所以我出题一般是使用hw模式.btw他也提供模式的自定义,想着如果有机会能不能搜罗一下其他的模式像是汉明距啥的,然后做下开源开发者这样.

> 产生的数据是trs格式,用python的trsfile库可以读取,主要包括数据的采集轨迹和对应的注释数据,整体结构还很清晰.

> NTRU实现有很多种版本,各有细微差异还都是官方的.第三轮提交文档中主要是分为steam Prime还是LPRrime,但是官方的代码又分hps和hrss两套算法实现版本,对应的参数不太一致；除此之外之前的NTRU open project实现还有具体差异,但代码删档了,无从考证.这次出题涉及到sample主要是在hps中,hrss系列使用的采样不完全一致,先找了相对好实现的.

> NTRU三元多项式采样的整体思想是,先采样大量的随机数,然后在随机数后附加2bit的三元信息（0,1,2,其中2代表-1）,然后对数组执行一遍类似快排的算法（但也不全是,感觉有点小差异）.为保证交换不会产生明显的timing问题,并更加贴合硬件执行,交换的算法比较有意思：用了一个比较复杂的比较系统,然后利用异或的逻辑,如果不需要交换那么掩码为0,整体都异或0,于是不交换；而如果需要交换,则将掩码设为全1,这样就可以留下a^b的结果,每个值都异或他,自然就得到了交换的结果.这个写法规避了分支判断会带来的时序差异,但是由于这个掩码全0还是全1有明显的汉明重差异,所以可以猜测会有明显的实际电源信号差异,原作者的实验结果也如是.那么我们的目的就是发现并还原这一组交换信号,自然就知道排序后的私钥表达式如何了.

> 但实际遇到一些难采样的问题是,由于标准实现中这个置换是通过宏定义实现的,而这段代码又是一个纯数据流代码,没什么控制性的代码,所以其分界线很模糊,时间片也不稳定（因为程序调用中间时间差很多,最短最长能差出两倍）或许通过电源模型好找相关性,但是在汉明重模型下太容易出错了,而这个顺序序列对误报又很严苛,所以这么出题也太折磨选手了,所以最后将宏定义写成函数,利用函数调用是压栈跳转的控制流来做分界,方便些.

> 理清这个思路,并熟悉trsfile和plt之后,其实实际做题就很容易了：先扒参数（使用的是比较小的原始参数N=251,q=256,p=3,d=72）,然后通过官方源码计算敏感交换部分执行了多少次,然后在trs中大胆猜测（指已知敏感信息是32和0,那么在示例中可以看看有什么情况,甚至说根据题目trs直接猜间隔,毕竟总有能肉眼分布的连续32的数据,来判断最小轮间隔）小心求证（既然知道这个间隔是函数调用控制流引起的,那么其他地方的函数调用会不会导致误报,是不是还有可以再区分的特征？）,然后扒出来序列,塞进源码中魔改一下就直接正向还原了,也没有多少逆向要读懂的部分.

> 看别人写的wp,也做不出来题.

## flag

> 