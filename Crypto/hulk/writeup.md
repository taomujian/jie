# Hulk

## 解题思路

> 下载附件,得到一个python文件,完全看不懂,越来越难了

> 这道题知道的内容有明文的前一部分,第一次加密的密文结果,第二次的IV、明文以及密文.由于cbc的特性,前一块加密的结果会当作后一块加密的初始向量IV,所以如果两块的IV和明文的异或结果一样,key也一样,那么他们加密后的密文也就一样.这里就可以构造第二次加密的输入,一字节一字节的爆破flag.

> 第一次加密：构造输入为31字节,这样第32字节就是flag的第一个字符. 

> 第二次加密：然后以第一次加密的密文结果的最后16字节作IV,对构造的明文进行加密,这里如果第二次加密的明文分组1和IV的异或值,等于第一次加密的明文分组2和密文分组1的异或值,那他们两块的密文结果肯定是一样的,所以爆破flag的第一字节,当两块密文一样时,就可以得到flag的第一个字节了,然后就可以爆破下一个字节.

> 经过测试,可以知道flag的长度是38字节,这里要注意分组加密的填充模式,如果刚好不用填充的话,会在明文后面填充16字节.所以如果第一次加密输入是10字节,加上38字节的flag,正好是16的整数倍,此时密文的结果为48+16=64字节,因为填充了16字节.

> 由于输入的长度要不大于48字节（96/2）,所以最多可以构造三块输入,由于flag长度38字节,是两块多一点,所以爆破明文分组3,这样就比较方便,不用考虑flag移位的时候前面块长度不够情况了.

## flag

> bctf{3c1fffb76f147d420f984ac651505905}