# broken-box 

## 解题思路

> nc连接后,输入字符,会给出签名.

> 首先通过nc连接到服务器,通过对比输出我们猜测这是一个RSA-CRT故障,这意味着我们在计算签名的时候，CRT发生了错误,也就是说明gcd（sᵉ - m，N）> 1,我们可以分解因子N，通过下面的代码来验证猜想

```
for sig in faulty:
    ggcd = gcd(ver(sig) - msg, N)

    if ggcd > 1:
        print "[!] Found factor {0}".format(ggcd)
        break

    for fsig in faulty:
        if fsig != sig:
            # try to detect constant errors
            ggcd = gcd(N + ver(sig) - ver(fsig), N)
            ggcd = ggcd * gcd(ver(sig - fsig), N)
            if ggcd > 1:
                print "[!] Found factor {0}".format(ggcd)
                break
if ggcd == 1:
    print '[-] No factors found...'
```

> 但是验证后并不存在错误，猜测错误来源是模数N或者指数d，进行新的尝试,首先，我们从服务中抽取大量签名,然后，我们把这个组合分成一个正确的签名和几个错误的签名

```
for line in f: sig = int(line) if ver(sig) == 2: valid.append(sig) else:
faulty.append(sig) ``` 假设我们有一个合适的签名`s`和一个错误的签名`f`

那么我们可以计算`s × f⁻¹ = mᵈ × (mᵈ⁻ʲ)⁻¹ = mʲ`

如果是单bit错误，则 `j = ±2ⁱ`

首先我们建立一个查找表

`python look_up = {pow(msg, pow(2,i), N) : i for i in range(0,1024)}`

这只是一种从`±2ⁱ mod N`快速确定`i`的方法。对于每个错误签名，我们计算 `s × q⁻¹` 和 `s⁻¹ × f` ，看表中是否有匹配。

该算法的详细描述如下： ``` algorithm brokenbox(m): output: secret exponent d

precomputation:
    compute Q[mⁱ] = i for i ∈ {0,1...,1024}

online computation:
    1. query oracle for signature of m
    2. check if sᵉ = m (mod N)
    3. if true, save it as reference value s.
        else, save in list L
    4. repeat 1-3 until sufficiently many signatures have been obtained
    5. for f ∈ L:
        compute s × f⁻¹ (mod N) and s⁻¹ × f (mod N)
        if s × f⁻¹ ∈ Q, set bit Q[s × f⁻¹] in d to 0
        if s⁻¹ × f ∈ Q, set bit Q[s⁻¹ × f] in d to 1
```

> 编写python脚本进行解密

``` 
在进行了大量运算后，我们填充了所有的位：

`data
???1???1??????0????0???0?0?11?1??1???1?1??1???????0010??1??10???????1001?1???????1?1?00?????????1?????0??0??1??0??
0??100?0?0?01??10?01????????10??0???1??????1??0???0???0???0?0?0000?110?????1????0001?011?0??0??1?????????????1????
??1??10???????0?1?10??????????0???0??0??0?????????1???1?1?1??????10?0110?????????0???1???1????0?0?0???????1???????
???1????????11?????1??1??0?????00????????1??0?1???10???????11??01000??0???1????1?0???00?1??1?10??0????0???1???1?1?
?0????????1????1?1??0????1????1????0??01??11??0????0???????0?10????0????0???0????????1?????????11??0???0?????1????
0????01????1???????100???????111?00?0??00????1?10??????????1?0????1???????0??1?0?11???11?????????????1??0???01????
????1???0?1??????0001??????1???010???????100?1??????10?????0?01??1???0??????????1??1??0???0??????00??1??11??01?0?0
1?0?1????00????0???0?0?1????0?0??1?0??1????10???????1???00????10??0????0?1??????1?1?0?1?????1?1?01???10??1??????0?
???10???1?????0?10??????????1???110???1?01??0?????1????11??0?????11??0????1??1?0???11?0??0????1?????0??1?????10?`

将填充好的信息继续运行，就得到了flag 
`python [+] Found 1520 valid and 1510 faulty signatures!
[+] Generating lookup... 
[+] Looking for matches and recovering secret
exponent... Secret exponent is:
1318114196677043534196699342738014984976469352105320281204477993086640079603572783402617238085
726375484075509084032393449039977882965644396676597161109348224128554215866738089041936064811376790441326881154721
3257515039998690149350105787817443487153162937855786664238603417924072736209641094219963164897214757
Check: True flag{br0k3n_h4rdw4r3_l34d5_70_b17_fl1pp1n6}`
```

## flag

> flag{br0k3n_h4rdw4r3_l34d5_70_b17_fl1pp1n6}