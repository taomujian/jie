# 恶臭的数据包

## 解题思路

> 下载附件后,得到1个cpp文件,文件格式很奇怪,具有奇怪的间距.

> 其中空白的区别实际上是二进制的.在这种情况下,制表符本来是1,空格是0,反之亦然.

> 首先,将所有不是新行的字符更改为另一个字符(在本例中为下划).

```
tr -c '\t \n' '_' < program.cpp
```

> 然后,将所有制表符都视为1.

```
tr -c '\t \n' '_' < program.cpp | tr '\t' 1
```

> 这意味着所有空格必须为0.
```
tr -c '\t \n' '_' < program.cpp | tr '\t' 1 | tr " " "0"
```

> 然后,将删除所有其余的下划线.

```
tr -c '\t \n' '_' < program.cpp | tr '\t' 1 | tr " " "0" | tr -d "_"
```

> 我最终得到了一些如下所示的结果：

```
000001110100
1
000001101000
1
000001100101
1
000001011111
1
000001100110
1
000001101100
```

> 这看起来确实很有希望,因为在此之后二进制表示法中,大多数行的长度相同.仅带有一行的行1必须是仅具有缩进的空白行,以使其看起来像源代码,并且由于尾随注释的原因,最后有些异常.

> 将其剪裁掉,实现具有更统一的值.

```
tr -c '\t \n' '_' < program.cpp | tr '\t' 1 | tr " " "0" | tr -d "_" | strings -n 3
```

```
000001110100
000001101000
000001100101
000001011111
000001100110
000001101100
000001100001
000001100111
000001011111
000001101001
000001110011
000001011111
000001010111
000001110000
000001010101
000001000001
000001001001
000001110100
000001110011
000001100001
000001100100
000001101101
000001101000
000001100001
000001101011
000001010
```

> 把得到2进制字符串转为字符串,得到flag

## flag

> flag{WpUAItsadmhak}